---
layout:     post
title:      三次握手和四次挥手
subtitle:   
date:       2018-08-13
author:     PyP
header-img: img/post-bg-os-metro.jpg
catalog: 	 true
tags:
    - TCP协议
    - 三次握手，四次挥手
    - 滑动窗口
    - UDP协议
---


# TCP协议
## 数据包格式
TCP协议数据包格式如下：
![](https://ws3.sinaimg.cn/large/006tNbRwly1fu9qpjgmz2j30h50bnaah.jpg)
部分字段解释如下:

* 源端口号和目的端口号: 用来标注数据交互双方进程
* 32位序号和32位确认序号: TCP是一个可靠的交互协议, 这两个序号用做传输过程中数据的标记, 保证数据的传输顺序以及重发
* URG/ACK/PSH/RST/SYN/FIN: 用来标记该请求包位于TCP连接中的什么阶段

## 交互过程
![](https://ws1.sinaimg.cn/large/006tNbRwly1fu9qw4ftr8j30be0c874n.jpg)
上图中每次连接线上的数字标记了此次数据包中的关键信息, 比如

* **SYN,1000(0),<mss 1460>** 代表: 请求包包含SYN标记, 32位序号为1000, 不包含数据, 带有一个mss的选项, 其值为1460
* **SYN,8000(0),ACK,1001,<mss 1024>** 代表: 请求包包含SYN和ACK标记, 32位序号为8000, 不会包含数据, 32位确认序号为1001, 同样带有mss选项  
  
tcp协议的交互过程：  
**1、建立连接**  

* 客户端发送包1, SYN代表请求建立连接, 第一个包序号为1000, 该序号的大小由操作系统内核维护, 每次发送都会自增, 自增数值就是发送的字节数, 其中mss选项代表最大段尺寸, 这是为了避免不必要的底层协议的拆包解包;
* 服务器返回包2, 包含的ACK 1001, 代表小于1001序号的包我都收到了, 下次请求发送大于等于1001包; 在该包中同时包含SYN 8000(0), 这段跟客户端交互的时候一样, 只是服务器端这头的序号为8000;
* 客户端返回包3, 里面只包含ACK 8001的包, 代表收到服务器的建立连接的包了  

至此, 连接建立完毕, 可以发送数据了, 该过程包含了客户端和服务器各一次请求和应答, 服务器的请求和应答放到一个包中做了, 一共包含3次包发送, 所以该过程又被称为三次握手。

**2、交换数据**  

* 客户端发送包4, 包含ACK 8001, 以及序号从1001~1020的20个字节的数据
* 服务器返回包5, 包含ACK 1021(因为包含20个字节), 以及序号从8001~8010的10个字节数据
* 客户端返回包6, 因为数据已经交互完毕, 所以只包含一个ACK 8011

这一段主要是要理解TCP交互的序号管理逻辑, 因为是全双工协议, 即服务器和客户端可以同时像对方发送数据, 所以需要客户端和服务器各维护一个序列号。如果是半双工协议的话, 就只需要一方维护一个序号即可。

**3、关闭连接**

* 客户端发送包7, 包含FIN标记, 1021
* 服务器返回包8, 只是应答ACK 1022
* 服务器再次返回包9, 包含FIN标记, 8011序列
* 客户端返回包10, 包含ACK 8012

在建立连接的时候, 服务器的请求和应答是合并到了一个包当中。但是在关闭连接的过程中, 就必须分开两个包来, 因为客户端关闭连接之后就不能再发送数据了, 但是服务器还可以发送数据给客户端, 直到服务器也发送FIN标记。这个过程被称为四次挥手。

## 滑动窗口
如上讲的都是一来一回的交互, 一般情况下可能会存在一方数据发得特别快, 另一方数据发得特别慢, 这种时候如果不做控制, 势必会让慢的这方数据处理不过来从而导致丢包。

TCP协议中采用了**滑动窗口协议**来解决该问题, 类似上面的**mss**, 再增加一个新的选项**win**, 告诉对方自己的滑动窗口大小, 对方在发送数据的时候每次发送数据就知道对方到底窗口空间还够不够, 如果不够了就不发了, 从而解决了一快一慢这种问题。

连接状态如上图所示，单独分析TIME_WAIT状态。

TIME_WAIT是主动关闭方在收到被动关闭方发的FIN包之后处于的状态, 这个包是主动关闭方收到的最后一个包了, 在收到这个包之后还不能直接就把连接给关闭了, 还得等待一段时间才能关闭, 等待时间为**2MSL**。

为什么要等待一段时间呢? 主要是两个原因:

* 在收到最后一个包之后主动关闭方还得发一个ACK回去, 这个ACK可能会丢包, 如果丢包, 对方还需要重新发最后一个FIN包, 如果收到重新发过来的FIN包的时候这边厢链接已经关闭, 则会导致链接异常终止;
* 不过第1点也不会造成太大的问题, 毕竟数据已经正常交互了。但是有另外一点风险更高, 就是如果不等待2MSL的话, 那么如果正好一个新链接又建立在相同的端口上, 那么上次的FIN包可能因为网络原因而延时迷途的包这个时候才送达该端口, 导致下一次连接出现问题;

所以一定要有一个TIME_WAIT的状态等待一段时间, 等待的MSL时间RFC上面建议是**2分钟**, 但是实际工作中测试往往是30秒。

但是如果你的服务是一个高并发短连接服务, TIME_WAIT可能会导致连接句柄被大量占用, 而你又相信服务内部是一个非常稳定的网络服务, 或者即使有两个连接交互出现故障也可以接受或者有应用层处理, 不希望有那么多的TIME_WAIT状态的连接, 一般有两种方式:

* 在建立连接的时候使用SO_REUSEADDR选项
* 在/etc/sysctl.conf中加入如下内容:

	net.ipv4.tcp_syncookies = 1  
	net.ipv4.tcp_tw_reuse = 1  
	net.ipv4.tcp_tw_recycle = 1  
	net.ipv4.tcp_fin_timeout = 30

然后执行/sbin/sysctl -p生效参数。


# UDP协议
![](https://ws4.sinaimg.cn/large/006tNbRwly1fu9rdrwvcxj30h806rt94.jpg)
UDP协议就简单很多了, 基本上就只包含源地址, 目的地址, 长度, 校验, 数据。

交互过程也不再像TCP这样经过很复杂的建立连接和关闭连接的过程了, 就直接每次都发送数据了, 这样会有如下的一些问题:

* 发送端只管发送数据, 如果在茫茫路由中该包丢了, 接收端并不知道
* 发送的多个包中, 在经过不同路由的时候, 可能达到时序跟发送的时候并不一样, 所以接收端可能拿到的是不同顺序的包
* 如果发送端很快, 而接收端很慢, 接收端处理不过来, 就会丢包

所以如前面所说, UDP协议并不保证数据的可靠性, 他一般用于一些高性能的场景, 且需要应用层再做一些简单的封装处理。
  


  
